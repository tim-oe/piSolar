# Renogy Wanderer RS232 Connection Guide

**✅ VERIFIED PINOUT - wanderer 10A**

---

![test bed](img/BT-1.jpg?raw=true)

If you have the BT-1 module, you can verify the pinouts by looking at the RJ12 cable colors and opening the head unit to see the RX, TX, and GND connectors.

--- 

This guide covers wiring a USB-to-RS232 adapter to the Renogy Wanderer charge controller.

---

For configuration details, see [CONFIGURATION.md](CONFIGURATION.md).  
For running as a service, see [SYSTEMD.md](SYSTEMD.md).


## Equipment Needed

- USB to RS232 adapter (must output RS232 voltage levels ±10V, not TTL)
- Raspberry Pi (or any computer with USB)
- RJ12 (6-pin) cable or RJ12 to screw terminal adapter
- Multimeter (for verification)

---

## Hardware Configuration

**USB-RS232 Adapter Requirements:**
- Must output RS232 voltage levels (±10V), not TTL (0-5V)
- Basic FTDI/TTL adapters will NOT work without a MAX232 level converter
- Waveshare USB to RS232 converter works (set to RS232 mode)

---

## RJ12 Connector Pinout

The Renogy Wanderer uses an **RJ12 (6P6C)** connector for communication.

**Pin Identification:**
- Hold RJ12 plug with tab/clip facing DOWN
- Cable entry facing AWAY from you
- Pins numbered LEFT to RIGHT: 1, 2, 3, 4, 5, 6

**RJ12 Pinout (Verified Working):**
```
Pin 1: TXD (Transmit Data - Controller OUTPUT)
Pin 2: RXD (Receive Data - Controller INPUT)
Pin 3: GND (Ground)
Pin 4: GND (Ground)
Pin 5: +10V (Power for BT module, do not use)
Pin 6: -5V (Power for BT module, do not use)
```

---

## RJ12 Wire Color Standards

**Standard References:**
- [RJ12/RJ11 Pin Configuration (Wikipedia)](https://en.wikipedia.org/wiki/Registered_jack#RJ11,_RJ14,_RJ25)
- [6P6C Modular Connector Standards](https://www.cables-solutions.com/rj11-rj12-rj25-pinout.html)

**⚠️ Critical Warning:** Not all manufacturers follow color standards. Always verify with a multimeter continuity test before connecting.

**Pre-Made Cable Options:**
- [DigiKey RJ12 Modular Cables](https://www.digikey.com/en/products/filter/modular-cables/458)
- For production: Cut one end off and wire directly to RS232 adapter (eliminates terminal blocks)

---

## Wiring Diagram

**RJ12 → DB9 RS232 Adapter:**
```
RJ12 Pin 1 (TXD) ──→ DB9 Pin 2 (RXD)  [Controller TX → Adapter RX]
RJ12 Pin 2 (RXD) ←── DB9 Pin 3 (TXD)  [Controller RX ← Adapter TX]
RJ12 Pin 3 (GND) ─── DB9 Pin 5 (GND)  [Ground]
```

**If using [Waveshare USB to RS232/485](https://www.waveshare.com/wiki/USB_TO_RS232/485) screw terminals:**
```
RJ12 Pin 1 (TXD) ──→ Adapter RXD
RJ12 Pin 2 (RXD) ←── Adapter TXD
RJ12 Pin 3 (GND) ─── Adapter GND
```

---

## Connection Notes

- **Cross TX and RX** - Controller TX connects to Adapter RX and vice versa
- Do NOT connect pins 5 or 6 (power rails for BT module)
- Only 3 wires needed: TX, RX, GND (pins 1, 2, 3)
- Pins 3 and 4 are both ground (tied together internally)
- Requires RS232 voltage levels (±10V), not TTL (0-5V)

---

## Communication Parameters

```
Baud Rate:    9600
Data Bits:    8
Stop Bits:    1
Parity:       None
Protocol:     Modbus RTU
Slave Addr:   1
```

---

## Raspberry Pi Setup

1. **Connect adapter to Raspberry Pi:**
   - Plug USB converter into any USB port
   - No drivers needed (automatic recognition)

2. **Verify connection:**
```bash
# List USB devices
lsusb

# Check for serial device
ls /dev/ttyUSB*

# Should show: /dev/ttyUSB0 (or ttyUSB1, ttyUSB2, etc.)
```

3. **Set permissions:**
```bash
# Add user to dialout group
sudo usermod -a -G dialout $USER

# Log out and back in for changes to take effect
```

---

## Testing Connection

### Loopback Test (Verify Serial Adapter)

Before connecting to the controller, verify your serial adapter works:

1. Disconnect from controller
2. Jumper TX to RX on the adapter (short pins 2 and 3 on DB9)
3. Run this test:

```python
#!/usr/bin/env python3
import serial

ser = serial.Serial('/dev/ttyUSB0', 9600, timeout=1)
test_msg = b'HELLO'
ser.write(test_msg)
response = ser.read(10)

if response == test_msg:
    print("LOOPBACK OK - serial adapter works")
else:
    print(f"LOOPBACK FAILED - sent {test_msg}, got {response}")
ser.close()
```

### Test with PyModbus

```bash
# Install dependencies
pip3 install pymodbus pyserial
```

**Test Script (pymodbus 3.10+):**
```python
#!/usr/bin/env python3
from pymodbus.client import ModbusSerialClient

# Create connection
client = ModbusSerialClient(
    port='/dev/ttyUSB0',
    baudrate=9600,
    bytesize=8,
    parity='N',
    stopbits=1,
    timeout=3
)

# Connect and read data
# Note: pymodbus 3.10+ uses device_id= instead of slave=
if client.connect():
    # Read battery SOC (register 0x0100)
    result = client.read_holding_registers(address=0x0100, count=1, device_id=1)
    if not result.isError():
        print(f"Battery SOC: {result.registers[0]}%")
    
    # Read battery voltage (register 0x0101)
    result = client.read_holding_registers(address=0x0101, count=1, device_id=1)
    if not result.isError():
        print(f"Battery Voltage: {result.registers[0] * 0.1}V")
    
    # Read solar voltage (register 0x0107)
    result = client.read_holding_registers(address=0x0107, count=1, device_id=1)
    if not result.isError():
        print(f"Solar Voltage: {result.registers[0] * 0.1}V")
    
    client.close()
else:
    print("Connection failed")
```

**Example Output:**
```
Battery SOC: 55%
Battery Voltage: 12.4V
Solar Voltage: 0.0V
```

**For pymodbus < 3.10, use `slave=` instead of `device_id=`:**
```python
result = client.read_holding_registers(0x0100, 1, slave=1)
```

---

## Common Modbus Registers

| Register | Description | Unit | Scale Factor |
|----------|-------------|------|--------------|
| 0x0100 | Battery SOC | % | 1 |
| 0x0101 | Battery Voltage | V | 0.1 |
| 0x0102 | Charging Current | A | 0.01 |
| 0x0103 | Controller Temperature | °C | 1 (signed) |
| 0x0107 | Solar Panel Voltage | V | 0.1 |
| 0x0108 | Solar Panel Current | A | 0.01 |
| 0x0109 | Solar Panel Power | W | 1 |
| 0x010B | Load Voltage | V | 0.1 |
| 0x010C | Load Current | A | 0.01 |
| 0x010D | Load Power | W | 1 |

---

## Troubleshooting

### No Communication

**Check the following:**
1. Verify adapter outputs RS232 levels (±10V), not TTL (0-5V)
2. Confirm crossover wiring: Controller TX → Adapter RX
3. Verify correct pins: Use RJ12 pins 1, 2, 3 (not 2, 3, 4 as some docs incorrectly state)
4. Ensure baud rate is 9600
5. Verify controller is powered on
6. Check `/dev/ttyUSB*` device exists
7. Confirm user is in `dialout` group

### Voltage Level Issues

A basic FTDI/TTL adapter (0-5V) will NOT work. You need:
- A proper RS232 adapter with MAX232 or similar level converter
- Or add a TTL-to-RS232 level shifter module between FTDI and controller

### Still Not Working?

```python
# Enable detailed Modbus debugging
import logging
logging.basicConfig()
log = logging.getLogger()
log.setLevel(logging.DEBUG)
```

---

## Safety Notes

- Always power off controllers before connecting/disconnecting
- Do not connect pins 5 or 6 (BT module power rails)
- Ensure all connections are secure before powering on

---

## Additional Resources

- **PyModbus Documentation:** https://pymodbus.readthedocs.io/
- **renogymodbus Python Library:** https://github.com/rosswarren/renogymodbus
- **NodeRenogy (confirms pinout):** https://github.com/sophienyaa/NodeRenogy
- **Community Pinout Reference:** https://www.wt4y.com/solar/renogy-charge-controller
- **Waveshare USB to RS232/485:** https://www.waveshare.com/usb-to-rs232-485.htm

---

## Revision History

- **v1.1** - Split from SERIAL.md, corrected pinout (pins 1,2,3 not 2,3,4)
- **v1.0** - Initial guide
